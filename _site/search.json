[
  {
    "objectID": "test2.html",
    "href": "test2.html",
    "title": "test2",
    "section": "",
    "text": "mean(rnorm(100))\n\n[1] 0.03173199"
  },
  {
    "objectID": "test2.html#cómo-estás",
    "href": "test2.html#cómo-estás",
    "title": "test2",
    "section": "",
    "text": "mean(rnorm(100))\n\n[1] 0.03173199"
  },
  {
    "objectID": "post/post_2/post2.html",
    "href": "post/post_2/post2.html",
    "title": "post 2",
    "section": "",
    "text": "Las posibilidades\n\\[y = \\beta_{0} + \\beta_{1}x\\]\n\nplot(rnorm(1000))\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "post/incertidumbre-de-una-calibracion-no-lineal/index.html",
    "href": "post/incertidumbre-de-una-calibracion-no-lineal/index.html",
    "title": "Incertidumbre de una calibración no lineal",
    "section": "",
    "text": "En un post anterior revisamos cómo estimar la incertidumbre de la concentración de una muestra problema, cuando ésta ha sido obtenida interpolando la señal instrumental en una curva de calibración lineal.\nLa expresión es relativamente simple y vimos también cómo podemos implementarla en el lenguaje de programación R a través del package chemCal.\nSin embargo, la vida no es tan sencilla. Recoradará estimad@ lector@ que está bastante documentada la presencia de desviaciones de la linealidad a altas concentraciones, fenómeno muy conocido en los métodos espectrofotométricos (Ley de Lambert-Beer). La severidad de estas desviaciones varía en función del detector, el analito y otros factores físico-químicos del sistema de medición.\nCuando existen estas desviaciones y deseamos llevar a cabo un test de linealidad, es muy probable que el test rechace el modelo lineal, por lo tanto, no podemos estimar la incertidumbre de calibración asumiendo este modelo. Si bien es cierto podemos reducir el rango lineal y diluir la muestra problema que está fuera del rango, la operación de dilución introduce nuevos errores (incluso errores humanos de transcripción bastante frecuentes).\nUna alternativa válida sería utilizar un modelo de calibración que capture esta no linealidad evitando así la dilución de la muestra, por lo tanto el problema se reduce a:\nSin embargo, de esta pregunta se desprende al mismo tiempo otra interrogante:\nExisten varios modelos de calibración no lineal:\nPor lo tanto, no existe una respuesta completamente correcta desde la prespectiva estadística, pues un modelo cuadrático sería tan válido como un polinomio cúbico. Desde el punto de vista químico podríamos preguntarnos ¿qué sentido químico tiene una curva de calibración polinómica de grado 5? ¿Son interpretables los parámetros del modelo? En un modelo lineal como el de Lambert-Beer: \\(y = \\beta_{0} + \\beta_{1}x\\) la pendiente de la curva de calibración tiene una interpretación química: es el producto entre coeficiente de extinción molar y la longitud de la celda:\n\\[\n\\underbrace{A}_\\text{y} = \\underbrace{\\epsilon \\cdot b}_\\text{$\\beta_{1}$} \\cdot\n\\underbrace{C}_\\text{x}\n(\\#eq:lambert)\n\\] Pero recuerde este sabio consejo de un monstruo de la estadística aplicada:\nPor lo tanto, tenemos que tomar una decisión. Y obviamente, como soy el autor de este humilde post, ya la tomé por Ud. En este artículo estimaremos la incertidumbre de calibración de un modelo polinómico de grado 2, también conocido como modelo cuadrático.\nNota: Desde el punto de vista estrictamente estadístico los modelos polinómicos, como la calibración cuadrática, son también modelos lineales ya que los coeficientes del modelo son lineales\n\\[y = \\beta_{0} + \\beta_{1}x + \\beta_{2}x^2 + \\epsilon\\]\nEn cambio, en un modelo del tipo exponencial:\n\\[y = \\beta_{0}\\cdot e^{\\beta_{1}x}\\]\nEl coeficiente \\(\\beta_{1}\\) no es una función lineal."
  },
  {
    "objectID": "post/incertidumbre-de-una-calibracion-no-lineal/index.html#estimación-de-incertidumbre-de-acuerdo-a-iso-8466-2",
    "href": "post/incertidumbre-de-una-calibracion-no-lineal/index.html#estimación-de-incertidumbre-de-acuerdo-a-iso-8466-2",
    "title": "Incertidumbre de una calibración no lineal",
    "section": "Estimación de incertidumbre de acuerdo a ISO 8466-2",
    "text": "Estimación de incertidumbre de acuerdo a ISO 8466-2\nDesde el punto de vista metrológico, la aproximación que indica esta norma es similar a lo que dicta la guía ISO GUM clásica, es decir, estima la incertidumbre a partir de un modelo de medición \\(y = f(x)\\). La “gracia” de esta norma es que nos ahorra tinta, pues la ecuación de incertidumbre ya está “algebraicamente manipulada”. No entraremos en los detalles de las primeras secciones de la norma los cuales estudian el comportamiento de la curvatura, es decir, si será posible encontrar un máximo o un mínimo, lo cual es clave en la utilidad del modelo cuadrático como función de calibración. Esto es importante porque recuerde que una función parabólica tiene dos soluciones, si existiera un máximo o un mínimo en el rango de trabajo, el modelo cuadrático no puede ser utilizado como función de calibración.\nLa siguiente ecuación calcula la incertidumbre expandida \\(I(\\hat{x}) = U_{\\hat{x}}\\) de la concentración de la muestra problema \\(\\hat{x}\\), interpolada en la curva de calibración no lineal \\(y = a + bx + cx^2\\). Corresponde a la ecuación (27) de la norma:\n\\[\nI(\\hat{x}) = \\frac{s_{y} \\cdot t_{n - 3,\\, 95\\%}}{b + 2c\\hat{x}} \\cdot\n            \\sqrt{\\frac{1}{N} + \\frac{1}{\\hat{N}} +\n            \\frac{(\\hat{x} - \\overline{x})^2 \\, Q_{x^4} +\n            \\left(\\hat{x}^2 - \\frac{\\sum x_{i}^{2}}{N} \\right)^2 Q_{xx} -\n            2(\\hat{x} - \\overline{x})\n            \\left(\\hat{x}^2 - \\frac{\\sum x_{i}^{2}}{N} \\right) Q_{x^3}}\n            {Q_{x^4} Q_{xx} - \\left( Q_{x^3} \\right)^2}}\n\\]\ndonde:\n\\[\ns_{y} = \\sqrt{\\frac{\\sum (y_{i} -\\hat{y})^2}{N - 3}}\n\\]\n\n\\(y_{i}\\) es la respuesta experimental observada del estándar \\(i\\), \\(\\hat{y}\\) es la respuesta instrumental que predice el modelo para el mismo estándar \\(i\\), por lo tanto \\(e_{i} = y_{i} - \\hat{y}\\) es el residuo. \\(N\\) es el número de calibrantes. ¿Por qué el denominador es \\(N - 3\\) y no \\(N -2\\) como en la calibración lineal? Porque el modelo cuadrático posee tres parámetros \\(a\\), \\(b\\) y \\(c\\).\n\\(t_{N - 3,\\, 95\\%}\\) es el valor del T de Student con \\(N - 3\\) grados de libertad y un 95% de confianza.\n\\(\\hat{N}\\) es el número de replicados independientes de la muestra problema. Como discutimos en otro post, esto no corresponde a inyectar \\(\\hat{N}\\) veces la misma muestra en el instrumento.\n\\(\\hat{x}\\) es la concentración de la muestra problema interpolada en la curva de calibración no lineal, la cual se obtiene resolviendo la ecuación cuadrática. Como Ud. recordará de sus años mozos esto siginifica que la concentración interpolada se obtiene a partir de:\n\n\\[\\hat{x} = \\frac{-b \\pm \\sqrt{b^2 - 4(a - y_{0})c}}{2c}\\] donde \\(y_{0}\\) es la señal instrumental de la muestra problema.\n\n\\(x_{i}\\) es la concentración del estándar \\(i\\)\n\\(\\overline{x} = \\sum_{i = 1}^{N} x_{i}\\) es el promedio de las concentraciones de los calibrantes.\n\nFinalmente:\n\\[\n\\begin{aligned}\nQ_{xx}  &= \\sum x_{i}^2 - \\frac{\\left(\\sum x_{i}\\right)^2}{N} \\\\\nQ_{x^3} &= \\sum x_{i}^3 - \\left(\\sum x_{i} \\times \\frac{\\sum x_{i}^2}{N}\\right) \\\\\nQ_{x^4} &= \\sum x_{i}^4 - \\frac{\\left(\\sum x_{i}^2\\right)^2}{N}\n\\end{aligned}\n\\]\nOk, nada del otro mundo. Es bien fea, pero sólo son operaciones de aritmética básica. Algunas observaciones:\nComo Ud. recordará en el caso de la calibración lineal, a partir de esta ecuación podemos inferir que si deseamos minimizar la incertidumbre de calibración no lineal podemos :\n\nAumentar el número de calibrantes \\(N\\)\nAumentar el número de replicados independientes de la muestra problema \\(\\hat{N}\\)\nAumentar la sensibilidad del método, que en el caso de la calibración cuadrática está dada por \\(b + 2c\\hat{x}\\), es decir, depende de la concentración de la muestra problema \\(\\hat{x}\\). En cambio, en la calibración lineal la sensibilidad era constante en todo el rango de concentración estudiado y correspondía a la pediente de la curva.\n\nEn el caso de la calibración lineal, la incertidumbre de calibración se minimiza en el centroide de la curva, en el caso del modelo cuadrático esto no siempre es así. Observe en la siguiente figura las bandas de confianza de ambos tipos de calibración:\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nAdvierta que ambos modelos comparten la propiedad que la mayor incertidumbre se encuentra en los extremos. Sin embargo, en la calibración cuadrática, para este conjunto de datos, la menor incertidumbre no está en el centro de la curva.\nOk, a continuación implementaremos la ecuación de incertidumbre en R con los datos del ejemplo de la sección 7 de la norma. La señal instrumental de la muestra problema es \\(y_{0} = 0.084\\) UA:\n\nN &lt;- length(x) # Número de calibrantes\nN.hat &lt;- 1     # Número de replicados de la muestra problema\nQxx &lt;- sum(x^2) - sum(x)^2/N\nQx3 &lt;- sum(x^3) -(sum(x) * sum(x^2)/N)\nQx4 &lt;- sum(x^4) - sum(x^2)^2/N\n\na &lt;- fit.nolineal$coefficients[1]\nb &lt;- fit.nolineal$coefficients[2]\nc &lt;- fit.nolineal$coefficients[3]\n\ns.y &lt;- summary(fit.nolineal)$sigma # Es lo que R denomina Residual standard error\nt &lt;- qt(0.975, N - 3) # El T de Student (¡Ya no se usan tablas!)\n\ny0 &lt;- 0.084 # Es la señal instrumental de la muestra problema\nx.hat &lt;- (-b + sqrt(b^2 - 4*(a - y0)*c))/(2*c) # Concentración de la muestra\n\nIx &lt;- (s.y * t)/(b + 2*c*x.hat) * sqrt(\n  1/N + 1/N.hat + ((x.hat - mean(x))^2*Qx4 + (x.hat^2 - sum(x^2)/N)^2 * Qxx -  \n  2*(x.hat - mean(x))*(x.hat^2 - sum(x^2)/N)*Qx3)/\n  (Qx4 * Qxx - Qx3^2)\n)\n\nIx &lt;- unname(Ix) # Simplemente es para dejar sólo el número\n\nLa concentración de la muestra es \\(\\hat{x} = 12.17\\) mg/L. Al aplicar esta metodología obtenemos una incertidumbre expandida de \\(I(\\hat{x}) = 0.63\\) mg/L, es decir, exactamente la misma que la que indica la norma ISO. Note que si Ud. quisiera combinar esta incertidumbre de calibración con algún otro factor (p.ej: masa de la muestra, volumen de aforo, etc.) debe primero tansformarla en incertidumbre estándar, dividiéndola por el factor de cobertura \\(k\\), que en este caso corresponde al t Student con \\(N - 3\\) grados de libertad al 95% de confianza (k = 2.36):\n\\[\nu_{\\hat{x}} = \\frac{U_{\\hat{x}}}{k} = 0.27\\, \\, \\text{mg/L}\n\\] Por lo tanto, si tuviéramos que informar el resultado de la concentración de la muestra interpolada en la curva de calibración no lineal informaríamos \\(12.17 \\pm 0.63\\) mg/L [nota mental: mmmm… esto de las cifras significativas da para otro post, pero dejémoslo así por ahora. No olvidar borrar este comentario.]\n¿Cómo varía esta incertidumbre de calibración no lineal con la concentración de la muestra? La siguiente figura muestra esta variación:\n\nx &lt;- seq(12, 66, by = 6) # Rango de concentración\nN &lt;- length(x)\nN.hat &lt;- 1\nmu.x &lt;- mean(x) # promedio de las concentraciones de los calibrantes\nsq.x &lt;- sum(x^2) # suma de las concentraciones de los calibrantes al cuadrado\nQxx &lt;- sum(x^2) - sum(x)^2/N\nQx3 &lt;- sum(x^3) -(sum(x) * sum(x^2)/N)\nQx4 &lt;- sum(x^4) - sum(x^2)^2/N\nt &lt;- qt(0.975, N - 3)\n\n# Para graficar la incertidumbre vs concentración, primero debemos crear una\n# función que tome un X (una concentración) y calcule el Y (incertidumbre)\nUx &lt;- function(x) {\n    U &lt;- s.y*t/(b + 2*c*x) * sqrt(\n    1/N + 1/N.hat + ((x - mu.x)^2*Qx4 + (x^2 - sq.x/N)^2 * Qxx -  \n    2*(x - mu.x)*(x^2 - sq.x/N)*Qx3)/\n    (Qx4 * Qxx - Qx3^2))\n    return(unname(U))\n}\n\n# Graficamos concentración (X) vs Incertidumbre (Y)\n\nplot(x, Ux(x), type = 'n',\n     main = 'Concentración vs Incertidumbre de calibración',\n     xlab = 'Concentración [mg/L]',\n     ylab = 'Incertidumbre expandida [mg/L]')\nlines(spline(x, Ux(x)), col = 'red')\n\n\n\n\nSe aprecia que la incertidumbre aumenta con la concentración en una forma no constante para concentraciones mayores a 20 mg/L. Tal como mencionamos anteriormente, el mínimo no se encuentra en el centro del rango de concentración como ocurre con la calibración lineal. Para encontrar el valor exacto de concentración que minimiza la incertidumbre en este rango, usamos el comando optimize:\n\n# Busca el mínimo de la función Ux en el intervalo de 12 a 66 mg/L\noptimize(Ux, interval = c(12, 66))\n\n$minimum\n[1] 20.29164\n\n$objective\n[1] 0.5808116\n\n\nLa concentración que minimiza la incertidumbre es 20.29 mg/L.\nMuy entretenido, pero la vida es corta y debemos ser eficientes por lo tanto, para evitarnos el “tedio” de implementar la fórmula a mano, utilizaremos el package investr el cual calcula exactamente la incertidumbre de calibración de un gran número de modelos de calibración, entre ellos, los modelos cuadráticos:\n\n# y0 es la señal de la muestra problema y0 = 0.084 UA\nlibrary(investr) # Cargamos la librería investr\nx.hat &lt;- invest(fit.nolineal, data = d, y0 = y0, interval = 'Wald')\nx.hat\n\n  estimate      lower      upper         se \n12.1672952 11.5400416 12.7945489  0.2652657 \n\n\ndonde:\n\nestimate es la concentración de la muestra problema\nupper es el extremo superior de la incertidumbre expandida \\(I(\\hat{x})\\)\nlower es el extremo inferior de la incertidumbre expandida \\(I(\\hat{x})\\)\nse es la incertidumbre estándar de calibración \\(u_{\\hat{x}}\\), la cual es exactamente igual a la obtenida por la fórmula anterior \\(u_{\\hat{x}} = \\frac{U_{\\hat{x}}}{k} = 0.27\\, \\, \\text{mg/L}\\)\n\nNote que si quisiéramos obener \\(I(\\hat{x})\\) a partir de esta tabla, tendríamos que hacer la siguiente operación \\(I(\\hat{x}) =\\) upper - estimate:\n\nx.hat$upper - x.hat$estimate\n\n[1] 0.6272536\n\n\nNo podemos usar el package chemCal que utilizamos en un post anterior para estimar la incertidumbre de calibración, porque este package sólo soporta calibraciones lineales."
  },
  {
    "objectID": "post/incertidumbre-de-una-calibracion-no-lineal/index.html#estimación-de-incertidumbre-mediante-guía-iso-gum",
    "href": "post/incertidumbre-de-una-calibracion-no-lineal/index.html#estimación-de-incertidumbre-mediante-guía-iso-gum",
    "title": "Incertidumbre de una calibración no lineal",
    "section": "Estimación de incertidumbre mediante Guía ISO GUM",
    "text": "Estimación de incertidumbre mediante Guía ISO GUM\nYa que la señal instrumental es una función de la concentración, entonces, podemos utilizar la aproximación ISO GUM clásica para estimar la incertidumbre de calibración. Por “clásica” me refiero a utilizar la aproximación de Taylor con las derivadas parciales. Esta guía dice lo siguiente:\n\nExpresar el mensurando como una ecuación de medición a través de una relación funcional con las magnitudes de entrada. En este caso el mensurando es la concentración \\(\\hat{x}\\) cuya ecuación de medición es la solución de la ecuación cuadrática \\(y_{0} = a + b\\hat{x} + c\\hat{x^2}\\) donde \\(y_{0}\\) es la señal de la muestra problema:\n\n\\[\n\\hat{x} = \\frac{-b \\pm \\sqrt{b^2 - 4(a - y_{0})c}}{2c}\n\\] 2. Identificación de las fuentes de incertidumbre. Al observar la ecuación de medición identificamos las siguientes fuentes de incertidumbre:\n\nParámetros del modelo cuadrático: \\(a\\), \\(b\\) y \\(c\\)\nSeñal instrumental de la muestra problema \\(y_{0}\\)\n\n\nEvaluación de las fuentes de incertidumbre:\n\n\nLas incertidumbres estándar de los parámetros del modelo pueden ser obtenidas directamente del ajuste cuadrático fit.nolineal:\n\n\n# parámetros del modelo\na &lt;- fit.nolineal$coeff[1]\nb &lt;- fit.nolineal$coeff[2]\nc &lt;- fit.nolineal$coeff[3]\n\n# las incertidumbres estándar de a, b y c las obtenemos con la función summary\nua &lt;- summary(fit.nolineal)$coefficients[1, 2]\nub &lt;- summary(fit.nolineal)$coefficients[2, 2]\nuc &lt;- summary(fit.nolineal)$coefficients[3, 2]\n\n\nLa incertidumbre estándar de la señal instrumental de la muestra problema también puede obtenerse del ajuste cuadrático y corresponde a la desviación estándar residual:\n\n\nuy0 &lt;- summary(fit.nolineal)$sigma\ny0 &lt;- 0.084 # dato del problema, es decir, la absorbancia de la muestra\n\n\nDeterminación de la incertidumbre estándar combinada \\(u_{\\hat{x}}\\) a través de la expresión:\n\n\\[\nu_{\\hat{x}}^2 = \\left( \\frac{\\partial{\\hat{x}}}{\\partial{y_{0}}}\\right) ^{2} (u_{y_{0}})^{2} +\n\\left( \\frac{\\partial{\\hat{x}}}{\\partial{a}}\\right) ^{2} (u_{a})^{2} +\n\\left( \\frac{\\partial{\\hat{x}}}{\\partial{b}}\\right) ^{2} (u_{b})^{2} +\n\\left( \\frac{\\partial{\\hat{x}}}{\\partial{c}}\\right )^{2} (u_{c})^{2}\n\\]\n“sólo” nos falta obtener las derivadas parciales (aguante ese código \\(\\LaTeX\\)):\n\\[\n\\begin{aligned}\n\\frac{\\partial{\\hat{x}}}{\\partial{y_{0}}} &=\n\\frac{1}{\\sqrt{b^{2} - 4c(a-y_{0})}} \\\\\n\\frac{\\partial{\\hat{x}}}{\\partial{a}} &=\n  \\frac{-1}{\\sqrt{b^{2} - 4c(a-y_{0})}} \\\\\n\\frac{\\partial{\\hat{x}}}{\\partial{b}} &=\n\\frac{-1 + \\frac{b}{\\sqrt{b^{2} - 4c(a-y_{0})}}}{2c} \\\\\n\\frac{\\partial{\\hat{x}}}{\\partial{c}} &=\n  \\frac{-a + y_{0}}{c\\sqrt{b^{2} - 4c(a-y_{0})}} -\n  \\frac{-b + \\sqrt{b^{2} - 4c(a-y_{0})}}{2c^{2}}\n\\end{aligned}\n\\]\n¡Listo! ahora debemos evaluar las expresiones. Pero como soy flojo, prefiero usar el excelente package metRology que hará todo el trabajo por mí:\n\nlibrary(metRology) # cargamos la librería\n\n\nAttaching package: 'metRology'\n\n\nThe following objects are masked from 'package:base':\n\n    cbind, rbind\n\nexpr &lt;- expression((-b + sqrt(b^2 - 4*(a - y0)*c))/(2*c)) # ecuación de medición\nx &lt;- list(a = a, b = b, c = c, y0 = y0) # valores de cada X input\nu &lt;- c(ua, ub, uc, uy0) # incertidumbres estándar de cada X input\nu.GUM &lt;- uncert(expr, x, u, method = 'GUM') # Usamos el método GUM\nu.GUM\n\n\nUncertainty evaluation\n\nCall:\n  uncert.expression(obj = expr, x = x, u = u, method = \"GUM\")\n\nExpression: (-b + sqrt(b^2 - 4 * (a - y0) * c))/(2 * c)\n\nEvaluation method:  GUM \n\nUncertainty budget:\n   x             u            c           u.c        \na  -5.621212e-03 2.474778e-03   -141.6217 -0.35048212\nb   7.670455e-03 1.420320e-04  -1723.1492 -0.24474238\nc  -2.504209e-05 1.787394e-06 -20966.0252 -0.03747454\ny0  8.400000e-02 1.478563e-03    141.6217  0.20939648\n\n   y:  12.16727\nu(y):  0.4774807 \n\n\n¿What? ¿Por qué obtuvimos una incertidumbre estándar de 0.477 y no la que calculamos con la ecuación de la norma ISO 0.265? Por la sencilla razón de que los parámetros de un modelo cuadrático no son independientes, sus covarianzas no son 0. Es más, algunas de las covarianzas son negativas. Observe la siguiente figura que fue obtenida simulando curvas de calibración cuadráticas. En la figura se muestra las correlaciones entre los tres parámetros del modelo no lineal:\n\n# Simularemos p = 200 curvas de calibración cuadráticas a partir de los datos \n# empíricos \n\np &lt;- 200 # Número de simulaciones\na.sim &lt;- numeric(p) # vector que guardará el parámetro a\nb.sim &lt;- numeric(p) # vector que guardará el parámetro b\nc.sim &lt;- numeric(p) # vector que guardará el parámetro c\n\n# Hacemos un loop\nfor(i in 1:p){\n  x.sim &lt;- seq(12, 66, by = 6)\n  y.sim &lt;- a + b*x.sim + c*x.sim^2 + rnorm(length(x.sim), 0, uy0)\n  fit.nolineal.sim &lt;- lm(y.sim ~ x.sim + I(x.sim^2))\n  a.sim[i] &lt;- fit.nolineal.sim$coeff[1]\n  b.sim[i] &lt;- fit.nolineal.sim$coeff[2]\n  c.sim[i] &lt;- fit.nolineal.sim$coeff[3]\n}\n\n# guardamos los parámetros simulados en un data frame que llamamos param.sim\nparam.sim &lt;- data.frame(a.sim, b.sim, c.sim) \n                                                \n# graficamos los parámetros simulados\nplot(param.sim)\n\n\n\n\nSe advierte claramente que existe una correlación negativa entre los parámetros \\(a\\) y \\(b\\), además entre \\(b\\) y \\(c\\). La correlación entre \\(a\\) y \\(c\\) es positiva. En rigor, habría que incorporar las derivadas parciales cruzadas y las covarianzas entre los parámetros. De sólo pensarlo, me dan ganas de procastinar aún más la escritura de este post, así que recurriremos al package metRology.\nLa parte “fácil” es obtener la matriz de covarianzas de los parámetros del modelo con el comando vcov:\n\nv &lt;- vcov(fit.nolineal)\ncolnames(v) &lt;- c('a', 'b', 'c') # solo cosmética para que aparezcan los nombres\nrownames(v) &lt;- c('a', 'b', 'c') # de los parámetros (es opcional)\nv\n\n              a             b             c\na  6.124524e-06 -3.337187e-07  3.910406e-09\nb -3.337187e-07  2.017310e-08 -2.491926e-10\nc  3.910406e-09 -2.491926e-10  3.194776e-12\n\n\nLa diagonal de esta matriz es precisamente la incertidumbre estándar al cuadrado de los parámetros (a.k.a sus varianzas). Si queremos, también podemos expresarla como matriz de correlaciones con el comando cov2cor:\n\nparam.cor &lt;- cov2cor(v)\nparam.cor\n\n           a          b          c\na  1.0000000 -0.9494193  0.8840269\nb -0.9494193  1.0000000 -0.9815865\nc  0.8840269 -0.9815865  1.0000000\n\n\nEn la diagonal de esta matriz obviamente esperamos correlación 1. Se observa claramente la alta correlación entre los parámetros, como dijimos anteriormente, algunas de ellas son negativas.\nLa parte “difícil” es que debemos incorporar la variable señal instrumental de la muestra problema \\(y_{0}\\), la cual obviamente es independiente de los parámetros del modelo:\n\n# Incorporamos la variable y0 que es independiente de los parámetros\nv &lt;- rbind(v, y0 = rep(0, 3)) \nv &lt;- cbind(v, y0 = rep(0, 4))\nv[4, 4] &lt;- uy0^2 # Asignamos al elemento de la 4a fila y 4a columna  \n                 # la varianza de y0\nv\n\n               a             b             c           y0\na   6.124524e-06 -3.337187e-07  3.910406e-09 0.000000e+00\nb  -3.337187e-07  2.017310e-08 -2.491926e-10 0.000000e+00\nc   3.910406e-09 -2.491926e-10  3.194776e-12 0.000000e+00\ny0  0.000000e+00  0.000000e+00  0.000000e+00 2.186147e-06\n\n\nAhora, incorporamos las covarianzas en el cálculo por método GUM:\n\nu.GUM.cov &lt;- uncert(expr, x, cov = v, method = \"GUM\")\nu.GUM.cov\n\n\nUncertainty evaluation\n\nCall:\n  uncert.expression(obj = expr, x = x, method = \"GUM\", cov = v)\n\nExpression: (-b + sqrt(b^2 - 4 * (a - y0) * c))/(2 * c)\n\nEvaluation method:  GUM \n\nUncertainty budget:\n   x             u            c           u.c        \na  -5.621212e-03 2.474778e-03   -141.6217 -0.35048212\nb   7.670455e-03 1.420320e-04  -1723.1492 -0.24474238\nc  -2.504209e-05 1.787394e-06 -20966.0252 -0.03747454\ny0  8.400000e-02 1.478563e-03    141.6217  0.20939648\n\n   y:  12.16727\nu(y):  0.2651904 \n\n\n¡Perfecto!, ahora sí, al incluir las covarianzas obtenemos resultados consistentes con el método descrito en la norma ISO 8466-2."
  },
  {
    "objectID": "post/incertidumbre-de-una-calibracion-no-lineal/index.html#estimación-con-el-método-de-monte-carlo",
    "href": "post/incertidumbre-de-una-calibracion-no-lineal/index.html#estimación-con-el-método-de-monte-carlo",
    "title": "Incertidumbre de una calibración no lineal",
    "section": "Estimación con el Método de Monte Carlo",
    "text": "Estimación con el Método de Monte Carlo\nNo detallaremos aquí cómo funciona el método de Monte Carlo, puede consultarlo en este post y en este otro.\nSería super simple si usamos el package metRology, el problema es que el package lanza un error numérico cuando existen covarianzas negativas. Probé el ejemplo que incluye el manual de metRology y el error se repite. Es un problema al evaluar la suma de las correlaciones. Le consulté al autor Steve Ellison, sin embargo, a la fecha (09 de junio 2020) aún no tengo respuesta, a pesar de que Steve siempre responde las consultas en forma muy expedita. Otros usuarios han tenido un problema similar y se ha abierto un hilo en stackoverflow.\nPor lo tanto, implementamos el método de Monte Carlo “a mano” utilizando el package MASS el cual permite generar muestras aleatorias multivariadas incluyendo las correlaciones:\n\n# No funciona metRology MC así que lo hicimos a mano\nlibrary(MASS) # cargamos la librería\n\n\nAttaching package: 'MASS'\n\n\nThe following object is masked from 'package:patchwork':\n\n    area\n\n# Generamos n muestras aleatorias multivariadas, cuyas medias \n# corresponden a los valores de a, b, c e y0\n# La matriz de covarianza Sigma = v la calculamos anteriormente\n\nset.seed(123) # Para que Ud. obtenga los mismos resultados\nmuestra.MC &lt;- mvrnorm(n = 10000, mu = c(a, b, c, y0), Sigma = v, empirical = T)\ncolnames(muestra.MC) &lt;- c('a', 'b', 'c', 'y0') # solo cosmética\nmuestra.MC &lt;- data.frame(muestra.MC) # lo guardamos como data.frame\nhead(muestra.MC) # muestra las primeras n = 6 simulaciones\n\n             a           b             c         y0\n1 -0.006371785 0.007697494 -2.535336e-05 0.08771566\n2 -0.006657346 0.007727893 -2.572028e-05 0.08385741\n3 -0.005338584 0.007654631 -2.437727e-05 0.08643112\n4 -0.006478276 0.007654191 -2.412670e-05 0.08417975\n5 -0.008126340 0.007832532 -2.697179e-05 0.08478106\n6 -0.005139204 0.007672558 -2.484339e-05 0.08644533\n\n\nCada fila es una simulación. Si, por ejemplo, calculamos el promedio de cada variable simulada, obtenemos un valor similar a los valores empíricos. A mayor número de simulaciones, más nos acercamos a valores que asumimos como verdaderos.\n\napply(muestra.MC, 2, mean) # promedio de cada columna\n\n            a             b             c            y0 \n-5.621212e-03  7.670455e-03 -2.504209e-05  8.400000e-02 \n\n\nBien, lo que tenemos que hacer es que en cada simulación debemos calcular la concentración de la muestra:\n\n# cargaré estas librerías sólo para facilitar la manipulación de los datos\nlibrary(magrittr)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ lubridate 1.9.3     ✔ tibble    3.2.1\n✔ purrr     1.0.2     ✔ tidyr     1.3.0\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ ggpp::annotate()   masks ggplot2::annotate()\n✖ tidyr::extract()   masks magrittr::extract()\n✖ dplyr::filter()    masks stats::filter()\n✖ dplyr::lag()       masks stats::lag()\n✖ dplyr::select()    masks MASS::select()\n✖ purrr::set_names() masks magrittr::set_names()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# Creamos una nueva variable llamada x.hat que corresponde a la concentración de\n# la muestra\nmuestra.MC &lt;- muestra.MC %&gt;% \n  mutate(x.hat = (-b + sqrt(b^2 - 4*(a - y0)*c))/(2*c))\nhead(muestra.MC) # muestra las primeras n = 6 simulaciones\n\n             a           b             c         y0    x.hat\n1 -0.006371785 0.007697494 -2.535336e-05 0.08771566 12.75935\n2 -0.006657346 0.007727893 -2.572028e-05 0.08385741 12.20883\n3 -0.005338584 0.007654631 -2.437727e-05 0.08643112 12.48521\n4 -0.006478276 0.007654191 -2.412670e-05 0.08417975 12.32289\n5 -0.008126340 0.007832532 -2.697179e-05 0.08478106 12.39039\n6 -0.005139204 0.007672558 -2.484339e-05 0.08644533 12.43752\n\n\nLa última columna corresponde a la concentración calculada para cada simulación. Por lo tanto, si queremos obtener la incertidumbre estándar de la concentración, basta calcular la desviación estándar de esa columna:\n\nmu.x.hat.MC &lt;- mean(muestra.MC$x.hat) # valor promedio de concentración\nu.x.hat.MC &lt;- sd(muestra.MC$x.hat) # incertidumbre estándar de la concentración\nu.x.hat.MC\n\n[1] 0.265344\n\n\nSe obtiene una incertidumbre estándar de calibración de 0.265 mg/L, la cual es consistente con los otros métodos estudiados. La siguiente figura muestra el histograma de las concentraciones simuladas:\n\nhist(muestra.MC$x.hat, \n     breaks = 20,\n     main = 'Concentraciones simuladas por Monte Carlo',\n     xlab = 'Concentración [mg/L]')\n\n\n\n\nFinalmente, la siguiente tabla resume los resultados de los tres métodos considerando la incertidumbre estándar de calibración:\n\ntabla &lt;- data.frame(Ix/t, u.GUM$u.y, u.GUM.cov$u.y, u.x.hat.MC)\nknitr::kable(tabla, \n             rownames = NA,\n             col.names = c('ISO', 'GUM', 'GUM/Covarianzas', 'Monte Carlo'),\n             align = 'l')\n\n\n\n\nISO\nGUM\nGUM/Covarianzas\nMonte Carlo\n\n\n\n\n0.2651904\n0.4774807\n0.2651904\n0.265344\n\n\n\n\n\nSe aprecia claramente una excelente concordancia entre los tres métodos. Sin embargo, para que el método GUM entregue resultados correctos, es necesario incorporar las covarianzas entre las variables input.\nEn un próximo post exploraremos el método Bootstrap, un método estadístico por excelencia para estimar incertidumbre sin utilizar un modelo de medición…\n\n¡Dejad que los datos hablen!"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "post 1\n\n\n\n\n\nEn el siguiente nivel podemos\n\n\n\n\n\n\n1 min\n\n\n\n\n\n\n  \n\n\n\n\npost 2\n\n\n\n\n\n\n\n\n\n\n\n\n1 min\n\n\n\n\n\n\n  \n\n\n\n\nIncertidumbre de una calibración no lineal\n\n\nMétodo GUM y Monte Carlo – Norma ISO 8466:2\n\n\n\n\n\n\n\n\n\n25 min\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analytical",
    "section": "",
    "text": "Finley Malloc is the Chief Data Scientist at Wengo Analytics. When not innovating on data platforms, Finley enjoys spending time unicycling and playing with her pet iguana."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Analytical",
    "section": "Education",
    "text": "Education\nUniversity of California, San Diego | San Diego, CA PhD in Mathematics | Sept 2011 - June 2015\nMacalester College | St. Paul MA B.A in Economics | Sept 2007 - June 2011"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "Analytical",
    "section": "Experience",
    "text": "Experience\nWengo Analytics | Head Data Scientist | April 2018 - present\nGeoScynce | Chief Analyst | Spet 2012 - April 2018"
  },
  {
    "objectID": "post/post_1/index.html",
    "href": "post/post_1/index.html",
    "title": "post 1",
    "section": "",
    "text": "hist(rnorm(1000))\n\n\n\n\n\n\n\n\n\nmean(35)\n\n[1] 35"
  },
  {
    "objectID": "post/post_1/index.html#comprobado",
    "href": "post/post_1/index.html#comprobado",
    "title": "post 1",
    "section": "",
    "text": "mean(35)\n\n[1] 35"
  },
  {
    "objectID": "talks.html",
    "href": "talks.html",
    "title": "talks",
    "section": "",
    "text": "hist(rnorm(1000))\n\n\n\n\n\nhist(rnorm(1000))\n\n\n\n\n\nhist(rnorm(1000))\n\n\n\n\n\nplot(rnorm(1000), rnorm(1000))\n\n\n\n\n\n\n\n Back to top"
  }
]