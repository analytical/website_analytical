{
  "hash": "bc9dae6928fe4cf3b4a74872c49e3ca1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Incertidumbre de una calibración no lineal\"\nsubtitle: \"Método GUM y Monte Carlo -- Norma ISO 8466:2\"\ndate: \"2020-06-06\"\nimage: 'incertidumbres.png'\n---\n\n\nEn un [post anterior](https://www.analytical.cl/post/como-calcular-la-incertidumbre-de-una-curva-de-calibracion/) \nrevisamos cómo estimar la incertidumbre de la concentración \nde una muestra problema, cuando ésta ha sido obtenida interpolando la señal \ninstrumental en una curva de calibración lineal.\n\nLa expresión es relativamente simple y vimos también cómo podemos implementarla\nen el lenguaje de programación `R` a través del package `chemCal`.\n\nSin embargo, la vida no es tan sencilla. Recoradará estimad@ lector@ que está \nbastante documentada la presencia de desviaciones de la linealidad \na altas concentraciones, fenómeno muy conocido en los métodos \nespectrofotométricos (Ley de Lambert-Beer). La severidad de estas desviaciones \nvaría en función del detector, el analito y otros factores físico-químicos\ndel sistema de medición.\n\nCuando existen estas desviaciones y deseamos llevar a cabo un \n[test de linealidad](https://www.analytical.cl/post/como-demuestro-que-mi-curva-de-calibracion-es-lineal/),\nes muy probable que el test rechace el modelo lineal, por lo tanto, no podemos\nestimar la incertidumbre de calibración asumiendo este modelo. Si bien es cierto\npodemos reducir el rango lineal y diluir la muestra problema que está fuera\ndel rango, la operación de dilución introduce nuevos errores (incluso errores \nhumanos de transcripción bastante frecuentes).\n\nUna alternativa válida sería utilizar un modelo de calibración que capture esta\nno linealidad evitando así la dilución de la muestra, \npor lo tanto el problema se reduce a:\n\n> ¿Cómo estimar la incertidumbre de una muestra problema que ha sido\n> obtenida a través de una curva de calibración no lineal?\n\nSin embargo, de esta pregunta se desprende al mismo tiempo otra interrogante:\n\n> ¿Cuál modelo de calibración no lineal utilizaré?\n\nExisten varios modelos de calibración no lineal:\n\n1. Polinomios\n2. New Rational (en realidad se llaman *aproximaciones de Padé*)\n3. Splines\n4. Loess\n5. etc.\n\n\nPor lo tanto, no existe una respuesta completamente correcta desde \nla prespectiva estadística, pues un modelo cuadrático sería tan válido como \nun polinomio cúbico. Desde el punto de vista químico podríamos preguntarnos\n¿qué sentido químico tiene una curva de calibración polinómica de grado 5?\n¿Son interpretables los parámetros del modelo? En un modelo lineal como el \nde Lambert-Beer: $y = \\beta_{0} + \\beta_{1}x$ la pendiente de la curva de \ncalibración tiene una interpretación química: es el producto entre coeficiente \nde extinción molar y la longitud de la celda:\n\n$$\n\\underbrace{A}_\\text{y} = \\underbrace{\\epsilon \\cdot b}_\\text{$\\beta_{1}$} \\cdot\n\\underbrace{C}_\\text{x}\n(\\#eq:lambert)\n$$\nPero recuerde este sabio consejo de un monstruo de la estadística aplicada:\n\n> *\"All models are wrong, but some are useful\"*\n> -- <cite>George Box</cite>\n\nPor lo tanto, tenemos que tomar una decisión. Y obviamente, como soy el autor de\neste humilde post, ya la tomé por Ud. En este artículo estimaremos la \nincertidumbre de calibración de un modelo polinómico de grado 2, también \nconocido como modelo cuadrático.\n\nNota: Desde el punto de vista **estrictamente estadístico** los modelos \npolinómicos, como la calibración cuadrática, son también modelos lineales ya que \nlos coeficientes del modelo son lineales\n\n$$y = \\beta_{0} + \\beta_{1}x + \\beta_{2}x^2 + \\epsilon$$\n\nEn cambio, en un modelo del tipo exponencial:\n\n$$y = \\beta_{0}\\cdot e^{\\beta_{1}x}$$\n\nEl coeficiente $\\beta_{1}$ no es una función lineal.\n\n# Métodos de estimación de incertidumbre de calibración\n\nEn este post ejemplificaremos y compararemos tres métodos de estimación\nde incertidumbre de calibración:\n\n1. Norma ISO 8466-2:2001 *Water quality -- Calibration and evaluation of \nanalytical methods and estimation of performance characteristics -- Part 2: \nCalibration strategy for non-linear second-order calibration functions.*\n\n2. Método GUM\n\n3. Método de Monte Carlo (Suplemento 1 ISO-GUM)\n\nImplementaremos todos los métodos en el lenguaje de programación `R`, explicando\npaso a paso el código fuente con el fin de que Ud. obtenga los mismos \nresultados, es decir, un **análisis reproducible**.\n\n# Datos de calibración\n\nPara ejemplificar los cálculos, utilizaremos los datos de calibración indicados\nen el ejemplo de la sección 7 de la norma ISO 8466-2. El siguiente código `R` \nnos permite ingresar los datos manualmente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ingresamos los datos de calibración de la sección 7 de la norma ISO 8466-2\n# x: concentración en mg/L\n# y: Absorbancia [UA]\n\nx <- c(12, 18, 24, 30, 36, 42, 48, 54, 60, 66)\ny <- c(0.083, 0.123, 0.164, 0.203, 0.240, 0.273, 0.303, 0.334, 0.364, 0.393)\n\nd <- data.frame(x, y) # creamos un data frame con las variables x e y (esto es\n                      # análogo a una matriz de datos en Excel con dos columnas)\n```\n:::\n\n\nA continuación graficamos la curva de calibración con la librería `ggplot2`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2) # cargamos la librería ggplot2\n\ntheme_set(theme_minimal()) # esto es sólo por una cuestión estética del gráfico\n\nggplot(d, aes(x = x, y = y)) +\n  geom_point(color = 'red') +\n  xlab('Concentración [mg/L]') +\n  ylab('Absorbancia [UA]')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nMmm... no sé Ud. pero yo veo una leve curvatura.\nComo lo vimos en un [post anterior](https://www.analytical.cl/post/como-demuestro-que-mi-curva-de-calibracion-es-lineal/)\nllevaremos a cabo un análisis estadístico básico para evaluar si el modelo de\ncalibración lineal es adecuado, o si nos inclinamos por la hipótesis de no \nlinealidad.\n\nComo no tenemos replicados de cada punto de calibración, haremos un Test de \nLinealidad de Mandel. Lo primero, es ajustar un modelo lineal a los datos \n$y = a + bx$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit.lineal <- lm(y ~ x, data = d) # ajustamos un modelo lineal y lo guardamos \n                                  # con el nombre fit.lineal\n\nsummary(fit.lineal) # para ver el análisis estadístico del ajuste\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x, data = d)\n\nResiduals:\n      Min        1Q    Median        3Q       Max \n-0.010636 -0.004720  0.001000  0.005727  0.009151 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 0.0250303  0.0058314   4.292  0.00264 ** \nx           0.0057172  0.0001368  41.803 1.18e-10 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.007453 on 8 degrees of freedom\nMultiple R-squared:  0.9954,\tAdjusted R-squared:  0.9949 \nF-statistic:  1747 on 1 and 8 DF,  p-value: 1.181e-10\n```\n\n\n:::\n:::\n\n\nEsta tabla nos dice que el intercepto del modelo es \n$a = 0.0250303$ y la pendiente $b = 0.0057172$.\nNote el alto coeficiente de determinación \n$r^{2} = 0.9954$ lo cual indica que es un \nbuen modelo. El coeficiente de correlación es \n$r = 0.998$ que si bien es un dato a\nconsiderar, no es una prueba formal de linealidad.\n\nLa siguiente figura muestra el ajuste lineal sobre los datos de calibración:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggpmisc) # para escribir ecuaciones dentro del gráfico\n\nggplot(d, aes(x = x, y = y)) +\n  geom_point(color = 'red') +\n  geom_smooth(method = 'lm', se = F, \n              size = 0.5) + # dibuja la curva de calibración lineal\n  xlab('Concentración [mg/L]') +\n  ylab('Absorbancia [UA]') +\n  stat_poly_eq(aes(label =  paste(stat(eq.label), stat(rr.label), \n                                  sep = \"*\\\", \\\"*\")), \n               formula = y ~ x, \n               parse = TRUE, \n               rr.digits = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot.lineal-1.png){width=672}\n:::\n:::\n\n\nSe observa que el ajuste lineal no es un buen modelo, pues no captura la \ncurvatura de los datos a pesar del alto coeficiente de correlación. \nEsto se oberva más claramente si obervamos el gráfico\nde residuos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(fit.lineal, which = 1, add.smooth = F, pch = 19, col = 'red', \n     main = 'Gráfico de residuos modelo lineal')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fit.lin.res-1.png){width=672}\n:::\n:::\n\n\nLa evidencia en contra del modelo lineal es abrumadora, el gráfico muestra \nclaramente un patrón en los residuos que indica que el modelo lineal \nno es adecuado. Sin embargo, a pesar de la evidencia, haremos el Test de Mandel\npara \"comprobar\" esta hipótesis. Para aplicar el Test de Mandel debemos ahora \najustar el modelo cuadrático y compararlo con el modelo lineal.\nPara ser consistentes en la notación de la\nnorma ISO 8466-2, definiremos el modelo de calibración cuadrático como:\n\n$$ \ny = a + bx + cx^2\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit.nolineal <- lm(y ~ x + I(x^2), data = d) # ajuste cuadrático y los guardamos \n                                          # con el nombre fit.nolineal\nsummary(fit.nolineal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x + I(x^2), data = d)\n\nResiduals:\n       Min         1Q     Median         3Q        Max \n-1.864e-03 -1.114e-03  6.818e-05  9.432e-04  1.939e-03 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept) -5.621e-03  2.475e-03  -2.271   0.0574 .  \nx            7.670e-03  1.420e-04  54.005 1.96e-10 ***\nI(x^2)      -2.504e-05  1.787e-06 -14.010 2.23e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.001479 on 7 degrees of freedom\nMultiple R-squared:  0.9998,\tAdjusted R-squared:  0.9998 \nF-statistic: 2.23e+04 on 2 and 7 DF,  p-value: 4.84e-14\n```\n\n\n:::\n:::\n\n\nSe obtiene una tabla similar que la del modelo lineal, con la adición del \ncoeficiente que acompaña al \n$x^2$: `I(x^2)` $= -2.504\\times 10^{-5}$. Note\nque el coeficiente de determinación del modelo cuadrático es mayor que el \ndel modelo lineal. Esto siempre se cumplirá, lo que hace el Test de Mandel es\ndiscernir si esta \"mejora\" en el modelo es \"significativa\". \n\nLa siguiente figura muestra el ajuste no lineal, el cual captura mucho mejor\nla curvatura de los datos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(d, aes(x = x, y = y)) +\n  geom_point(color = 'red') +\n  geom_smooth(method = 'lm',         # dibuja la curva de calibración no lineal\n              se = F, \n              formula = y ~ x + I(x^2), size = 0.5) + \n  xlab('Concentración [mg/L]') +\n  ylab('Absorbancia [UA]') +\n  stat_poly_eq(aes(label =  paste(stat(eq.label), stat(rr.label), \n                                  sep = \"*\\\", \\\"*\")),\n               formula = y ~ x + I(x^2), \n               parse = TRUE, \n               rr.digits = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot.nolineal-1.png){width=672}\n:::\n:::\n\n\n\nOk, aplicamos\nel Test de Mandel con el comando `anova`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(fit.lineal, fit.nolineal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nModel 1: y ~ x\nModel 2: y ~ x + I(x^2)\n  Res.Df        RSS Df  Sum of Sq      F    Pr(>F)    \n1      8 0.00044442                                   \n2      7 0.00001530  1 0.00042912 196.29 2.235e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\nEl p-value del test de Mandel es $2.23\\times 10^{-6}$, el cual de acuerdo a \nla interpretación tradicional, indica que el modelo lineal no es adecuado para \nlos datos de calibración.\n\nProcedamos, entonces, a estimar la incertidumbre de la concentración $\\hat{x}$\nde una muestra problema, cuyo valor fue obtenido interpolando la señal \ninstrumental en el modelo de calibración no lineal.\n\n## Estimación de incertidumbre de acuerdo a ISO 8466-2\n\nDesde el punto de vista metrológico, la aproximación que indica esta norma es \nsimilar a lo que dicta la guía ISO GUM clásica, es decir, \nestima la incertidumbre a partir de un modelo de medición $y = f(x)$. \nLa \"gracia\" de esta norma es que nos \nahorra tinta, pues la ecuación de incertidumbre ya está \"algebraicamente \nmanipulada\". No entraremos en los detalles de las primeras secciones de la\nnorma los cuales estudian el comportamiento de la curvatura, es decir, si será\nposible encontrar un máximo o un mínimo, lo cual es clave en la utilidad del \nmodelo cuadrático como función de calibración. Esto es\nimportante porque recuerde que una función parabólica tiene dos soluciones, si \nexistiera un máximo o un mínimo en el rango de trabajo, el modelo cuadrático no \npuede ser utilizado como función de calibración.\n\nLa siguiente ecuación calcula la **incertidumbre expandida** \n$I(\\hat{x}) = U_{\\hat{x}}$ de la concentración de la muestra problema $\\hat{x}$, \ninterpolada en la curva de calibración no lineal $y = a + bx + cx^2$. \nCorresponde a la ecuación (27) de la norma:\n\n\n$$\nI(\\hat{x}) = \\frac{s_{y} \\cdot t_{n - 3,\\, 95\\%}}{b + 2c\\hat{x}} \\cdot\n            \\sqrt{\\frac{1}{N} + \\frac{1}{\\hat{N}} + \n            \\frac{(\\hat{x} - \\overline{x})^2 \\, Q_{x^4} + \n            \\left(\\hat{x}^2 - \\frac{\\sum x_{i}^{2}}{N} \\right)^2 Q_{xx} -\n            2(\\hat{x} - \\overline{x}) \n            \\left(\\hat{x}^2 - \\frac{\\sum x_{i}^{2}}{N} \\right) Q_{x^3}}\n            {Q_{x^4} Q_{xx} - \\left( Q_{x^3} \\right)^2}}\n$$\n\ndonde:\n\n$$\ns_{y} = \\sqrt{\\frac{\\sum (y_{i} -\\hat{y})^2}{N - 3}}\n$$\n\n- $y_{i}$ es la respuesta experimental observada del estándar $i$, $\\hat{y}$ es la\nrespuesta instrumental que predice el modelo para el mismo estándar $i$, por lo\ntanto $e_{i} = y_{i} - \\hat{y}$ es el residuo. $N$ es el número de calibrantes. \n¿Por qué el denominador es $N - 3$ y no $N -2$ como en la calibración lineal? \nPorque el modelo cuadrático posee tres parámetros $a$, $b$ y $c$.\n\n- $t_{N - 3,\\, 95\\%}$ es el valor del T de Student con $N - 3$ grados de \nlibertad y un 95% de confianza.\n\n- $\\hat{N}$ es el número de replicados \nindependientes de la muestra problema. Como discutimos en \n[otro post](https://www.analytical.cl/post/como-calcular-la-incertidumbre-de-una-curva-de-calibracion/), \nesto no corresponde a inyectar $\\hat{N}$ veces la misma muestra en el \ninstrumento.\n\n- $\\hat{x}$ es la concentración de la muestra problema interpolada en la curva\nde calibración no lineal, la cual se obtiene resolviendo la ecuación\ncuadrática. Como Ud. recordará de sus años mozos esto siginifica que \nla concentración interpolada se obtiene a partir de:\n\n$$\\hat{x} = \\frac{-b \\pm \\sqrt{b^2 - 4(a - y_{0})c}}{2c}$$\ndonde $y_{0}$ es la señal instrumental de la muestra problema.\n\n- $x_{i}$ es la concentración del estándar $i$\n\n- $\\overline{x} = \\sum_{i = 1}^{N} x_{i}$ es el promedio de las concentraciones \nde los calibrantes.\n\nFinalmente:\n\n$$\n\\begin{aligned}\nQ_{xx}  &= \\sum x_{i}^2 - \\frac{\\left(\\sum x_{i}\\right)^2}{N} \\\\\nQ_{x^3} &= \\sum x_{i}^3 - \\left(\\sum x_{i} \\times \\frac{\\sum x_{i}^2}{N}\\right) \\\\\nQ_{x^4} &= \\sum x_{i}^4 - \\frac{\\left(\\sum x_{i}^2\\right)^2}{N}\n\\end{aligned}\n$$\n\nOk, nada del otro mundo. Es bien fea, pero sólo son operaciones de aritmética\nbásica. Algunas observaciones:\n\nComo Ud. recordará en el caso de la calibración lineal, a partir de esta\necuación podemos inferir que si deseamos minimizar la incertidumbre de \ncalibración no lineal podemos :\n\n1. Aumentar el número de calibrantes $N$\n2. Aumentar el número de replicados independientes de la muestra problema $\\hat{N}$\n3. Aumentar la sensibilidad del método, que en el caso de la calibración\ncuadrática está dada por $b + 2c\\hat{x}$, es decir, depende de la concentración \nde la muestra problema $\\hat{x}$. En cambio, en la calibración lineal la \nsensibilidad era constante en todo el rango de concentración estudiado y \ncorrespondía a la pediente de la curva.\n\nEn el caso de la calibración lineal, la incertidumbre de calibración se minimiza\nen el centroide de la curva, en el caso del modelo cuadrático esto no siempre\nes así. Observe en la siguiente figura las bandas de confianza de ambos tipos de \ncalibración:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/patch-1.png){width=672}\n:::\n:::\n\n\nAdvierta que ambos modelos comparten la propiedad que la mayor incertidumbre se\nencuentra en los extremos. Sin embargo, en la calibración cuadrática, para este \nconjunto de datos, la menor incertidumbre no está en el centro de la curva.\n\nOk, a continuación implementaremos la ecuación de incertidumbre en `R` con los\ndatos del ejemplo de la sección 7 de la norma. La señal instrumental de la \nmuestra problema es $y_{0} = 0.084$ UA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- length(x) # Número de calibrantes\nN.hat <- 1     # Número de replicados de la muestra problema\nQxx <- sum(x^2) - sum(x)^2/N\nQx3 <- sum(x^3) -(sum(x) * sum(x^2)/N)\nQx4 <- sum(x^4) - sum(x^2)^2/N\n\na <- fit.nolineal$coefficients[1]\nb <- fit.nolineal$coefficients[2]\nc <- fit.nolineal$coefficients[3]\n\ns.y <- summary(fit.nolineal)$sigma # Es lo que R denomina Residual standard error\nt <- qt(0.975, N - 3) # El T de Student (¡Ya no se usan tablas!)\n\ny0 <- 0.084 # Es la señal instrumental de la muestra problema\nx.hat <- (-b + sqrt(b^2 - 4*(a - y0)*c))/(2*c) # Concentración de la muestra\n\nIx <- (s.y * t)/(b + 2*c*x.hat) * sqrt(\n  1/N + 1/N.hat + ((x.hat - mean(x))^2*Qx4 + (x.hat^2 - sum(x^2)/N)^2 * Qxx -  \n  2*(x.hat - mean(x))*(x.hat^2 - sum(x^2)/N)*Qx3)/\n  (Qx4 * Qxx - Qx3^2)\n)\n\nIx <- unname(Ix) # Simplemente es para dejar sólo el número\n```\n:::\n\n\nLa concentración de la muestra es $\\hat{x} = 12.17$ mg/L.\nAl aplicar esta metodología obtenemos una incertidumbre expandida de \n$I(\\hat{x}) = 0.63$ mg/L, es decir, exactamente la misma que la que \nindica la norma ISO. Note que si Ud. quisiera combinar esta incertidumbre de \ncalibración con algún otro factor (p.ej: masa de la muestra, volumen de aforo, \netc.) debe primero tansformarla en incertidumbre estándar, dividiéndola por el \nfactor de cobertura $k$, que en este caso corresponde al t Student con $N - 3$ \ngrados de libertad al 95% de confianza (k = 2.36):\n\n$$\nu_{\\hat{x}} = \\frac{U_{\\hat{x}}}{k} = 0.27\\, \\, \\text{mg/L}\n$$\nPor lo tanto, si tuviéramos que informar el resultado de la concentración\nde la muestra interpolada en la curva de calibración no lineal informaríamos\n$12.17 \\pm 0.63$ mg/L [*nota mental: mmmm... esto de\nlas cifras significativas da para otro post, pero dejémoslo así por ahora. \nNo olvidar borrar este comentario.*]\n\n¿Cómo varía esta incertidumbre de calibración no lineal con la concentración de\nla muestra? La siguiente figura muestra esta variación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(12, 66, by = 6) # Rango de concentración\nN <- length(x)\nN.hat <- 1\nmu.x <- mean(x) # promedio de las concentraciones de los calibrantes\nsq.x <- sum(x^2) # suma de las concentraciones de los calibrantes al cuadrado\nQxx <- sum(x^2) - sum(x)^2/N\nQx3 <- sum(x^3) -(sum(x) * sum(x^2)/N)\nQx4 <- sum(x^4) - sum(x^2)^2/N\nt <- qt(0.975, N - 3)\n\n# Para graficar la incertidumbre vs concentración, primero debemos crear una\n# función que tome un X (una concentración) y calcule el Y (incertidumbre)\nUx <- function(x) {\n    U <- s.y*t/(b + 2*c*x) * sqrt(\n    1/N + 1/N.hat + ((x - mu.x)^2*Qx4 + (x^2 - sq.x/N)^2 * Qxx -  \n    2*(x - mu.x)*(x^2 - sq.x/N)*Qx3)/\n    (Qx4 * Qxx - Qx3^2))\n    return(unname(U))\n}\n\n# Graficamos concentración (X) vs Incertidumbre (Y)\n\nplot(x, Ux(x), type = 'n',\n     main = 'Concentración vs Incertidumbre de calibración',\n     xlab = 'Concentración [mg/L]',\n     ylab = 'Incertidumbre expandida [mg/L]')\nlines(spline(x, Ux(x)), col = 'red')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/u.vs.con-1.png){width=672}\n:::\n:::\n\nSe aprecia que la incertidumbre aumenta con la concentración en una forma no \nconstante para concentraciones mayores a 20 mg/L. \nTal como mencionamos anteriormente, el mínimo no se encuentra en el \ncentro del rango de concentración como ocurre con la calibración lineal. Para \nencontrar el valor exacto de concentración que minimiza la incertidumbre en este \nrango, usamos el comando `optimize`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Busca el mínimo de la función Ux en el intervalo de 12 a 66 mg/L\noptimize(Ux, interval = c(12, 66))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$minimum\n[1] 20.29164\n\n$objective\n[1] 0.5808116\n```\n\n\n:::\n:::\n\n\nLa concentración que minimiza la incertidumbre es \n20.29 mg/L.\n\n\nMuy entretenido, pero la vida es corta y debemos ser eficientes por lo tanto, \npara evitarnos el \"tedio\" de implementar la fórmula a mano, utilizaremos\nel package `investr` el cual calcula exactamente la incertidumbre de \ncalibración de un gran número de modelos de calibración, entre ellos, los \nmodelos cuadráticos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# y0 es la señal de la muestra problema y0 = 0.084 UA\nlibrary(investr) # Cargamos la librería investr\nx.hat <- invest(fit.nolineal, data = d, y0 = y0, interval = 'Wald')\nx.hat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  estimate      lower      upper         se \n12.1672952 11.5400416 12.7945489  0.2652657 \n```\n\n\n:::\n:::\n\n\ndonde:\n\n- `estimate` es la concentración de la muestra problema\n- `upper` es el extremo superior de la incertidumbre expandida $I(\\hat{x})$\n- `lower` es el extremo inferior de la incertidumbre expandida $I(\\hat{x})$\n- `se` es la incertidumbre estándar de calibración $u_{\\hat{x}}$, la cual es \nexactamente igual a la obtenida por la fórmula anterior\n$u_{\\hat{x}} = \\frac{U_{\\hat{x}}}{k} = 0.27\\, \\, \\text{mg/L}$\n\nNote que si quisiéramos obener $I(\\hat{x})$ a partir de esta tabla, tendríamos \nque hacer la siguiente operación $I(\\hat{x}) =$ `upper` - `estimate`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx.hat$upper - x.hat$estimate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6272536\n```\n\n\n:::\n:::\n\n\n\nNo podemos usar el package `chemCal` que utilizamos\nen un [post anterior](https://www.analytical.cl/post/como-calcular-la-incertidumbre-de-una-curva-de-calibracion/) \npara estimar la incertidumbre de calibración, porque este package sólo soporta \ncalibraciones lineales.\n\n\n## Estimación de incertidumbre mediante Guía ISO GUM\n\nYa que la señal instrumental es una función de la concentración, entonces, \npodemos utilizar la aproximación ISO GUM clásica para estimar la incertidumbre\nde calibración. Por \"clásica\" me refiero a utilizar la aproximación de Taylor\ncon las derivadas parciales. Esta guía dice lo siguiente:\n\n1. Expresar el mensurando como una ecuación de medición a través de una relación\nfuncional con las magnitudes de entrada. En este caso el mensurando es la \nconcentración $\\hat{x}$ cuya ecuación de medición es la solución de la ecuación\ncuadrática $y_{0} = a + b\\hat{x} + c\\hat{x^2}$ donde $y_{0}$ es la señal de la \nmuestra problema:\n\n$$\n\\hat{x} = \\frac{-b \\pm \\sqrt{b^2 - 4(a - y_{0})c}}{2c}\n$$\n2. Identificación de las fuentes de incertidumbre. Al observar la ecuación de \nmedición identificamos las siguientes fuentes de incertidumbre:\n\n- Parámetros del modelo cuadrático: $a$, $b$ y $c$\n- Señal instrumental de la muestra problema $y_{0}$\n\n3. Evaluación de las fuentes de incertidumbre: \n\n- Las incertidumbres estándar de los parámetros del modelo pueden ser obtenidas\ndirectamente del ajuste cuadrático `fit.nolineal`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# parámetros del modelo\na <- fit.nolineal$coeff[1]\nb <- fit.nolineal$coeff[2]\nc <- fit.nolineal$coeff[3]\n\n# las incertidumbres estándar de a, b y c las obtenemos con la función summary\nua <- summary(fit.nolineal)$coefficients[1, 2]\nub <- summary(fit.nolineal)$coefficients[2, 2]\nuc <- summary(fit.nolineal)$coefficients[3, 2]\n```\n:::\n\n\n\n- La incertidumbre estándar de la señal instrumental de la muestra problema\ntambién puede obtenerse del ajuste cuadrático y corresponde a la \ndesviación estándar residual:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuy0 <- summary(fit.nolineal)$sigma\ny0 <- 0.084 # dato del problema, es decir, la absorbancia de la muestra\n```\n:::\n\n\n4. Determinación de la incertidumbre estándar combinada $u_{\\hat{x}}$ a través \nde la expresión:\n\n$$\nu_{\\hat{x}}^2 = \\left( \\frac{\\partial{\\hat{x}}}{\\partial{y_{0}}}\\right) ^{2} (u_{y_{0}})^{2} + \n\\left( \\frac{\\partial{\\hat{x}}}{\\partial{a}}\\right) ^{2} (u_{a})^{2} + \n\\left( \\frac{\\partial{\\hat{x}}}{\\partial{b}}\\right) ^{2} (u_{b})^{2} +\n\\left( \\frac{\\partial{\\hat{x}}}{\\partial{c}}\\right )^{2} (u_{c})^{2}\n$$\n\n\"sólo\" nos falta obtener las derivadas parciales (aguante ese código $\\LaTeX$):\n\n$$\n\\begin{aligned}\n\\frac{\\partial{\\hat{x}}}{\\partial{y_{0}}} &= \n\\frac{1}{\\sqrt{b^{2} - 4c(a-y_{0})}} \\\\\n\\frac{\\partial{\\hat{x}}}{\\partial{a}} &=\n  \\frac{-1}{\\sqrt{b^{2} - 4c(a-y_{0})}} \\\\\n\\frac{\\partial{\\hat{x}}}{\\partial{b}} &=\n\\frac{-1 + \\frac{b}{\\sqrt{b^{2} - 4c(a-y_{0})}}}{2c} \\\\\n\\frac{\\partial{\\hat{x}}}{\\partial{c}} &=\n  \\frac{-a + y_{0}}{c\\sqrt{b^{2} - 4c(a-y_{0})}} - \n  \\frac{-b + \\sqrt{b^{2} - 4c(a-y_{0})}}{2c^{2}}\n\\end{aligned}\n$$\n\n¡Listo! ahora debemos evaluar las expresiones. Pero como soy flojo, \nprefiero usar el excelente package `metRology` que hará todo el trabajo por\nmí:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(metRology) # cargamos la librería\n\nexpr <- expression((-b + sqrt(b^2 - 4*(a - y0)*c))/(2*c)) # ecuación de medición\nx <- list(a = a, b = b, c = c, y0 = y0) # valores de cada X input\nu <- c(ua, ub, uc, uy0) # incertidumbres estándar de cada X input\nu.GUM <- uncert(expr, x, u, method = 'GUM') # Usamos el método GUM\nu.GUM\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nUncertainty evaluation\n\nCall:\n  uncert.expression(obj = expr, x = x, u = u, method = \"GUM\")\n\nExpression: (-b + sqrt(b^2 - 4 * (a - y0) * c))/(2 * c)\n\nEvaluation method:  GUM \n\nUncertainty budget:\n   x             u            c           u.c        \na  -5.621212e-03 2.474778e-03   -141.6217 -0.35048212\nb   7.670455e-03 1.420320e-04  -1723.1492 -0.24474238\nc  -2.504209e-05 1.787394e-06 -20966.0252 -0.03747454\ny0  8.400000e-02 1.478563e-03    141.6217  0.20939648\n\n   y:  12.16727\nu(y):  0.4774807 \n```\n\n\n:::\n:::\n\n\n¿What? ¿Por qué obtuvimos una incertidumbre estándar de 0.477 \ny no la que calculamos con la ecuación de la norma ISO 0.265?\nPor la sencilla razón de que los parámetros de un modelo cuadrático no son\nindependientes, sus covarianzas no son 0. Es más, algunas de las covarianzas\nson negativas. Observe la siguiente figura que fue obtenida simulando \ncurvas de calibración cuadráticas. En la figura se muestra las correlaciones\nentre los tres parámetros del modelo no lineal:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simularemos p = 200 curvas de calibración cuadráticas a partir de los datos \n# empíricos \n\np <- 200 # Número de simulaciones\na.sim <- numeric(p) # vector que guardará el parámetro a\nb.sim <- numeric(p) # vector que guardará el parámetro b\nc.sim <- numeric(p) # vector que guardará el parámetro c\n\n# Hacemos un loop\nfor(i in 1:p){\n  x.sim <- seq(12, 66, by = 6)\n  y.sim <- a + b*x.sim + c*x.sim^2 + rnorm(length(x.sim), 0, uy0)\n  fit.nolineal.sim <- lm(y.sim ~ x.sim + I(x.sim^2))\n  a.sim[i] <- fit.nolineal.sim$coeff[1]\n  b.sim[i] <- fit.nolineal.sim$coeff[2]\n  c.sim[i] <- fit.nolineal.sim$coeff[3]\n}\n\n# guardamos los parámetros simulados en un data frame que llamamos param.sim\nparam.sim <- data.frame(a.sim, b.sim, c.sim) \n                                                \n# graficamos los parámetros simulados\nplot(param.sim)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nSe advierte claramente que existe una correlación negativa entre los parámetros\n$a$ y $b$, además entre $b$ y $c$. La correlación entre $a$ y $c$ es positiva.\nEn rigor, habría que incorporar las derivadas parciales cruzadas y las \ncovarianzas entre los parámetros. De sólo pensarlo, me dan ganas de \nprocastinar aún más la escritura de este post, así que recurriremos al \npackage `metRology`.\n\nLa parte \"fácil\" es obtener la matriz de covarianzas de los parámetros del\nmodelo con el comando `vcov`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- vcov(fit.nolineal)\ncolnames(v) <- c('a', 'b', 'c') # solo cosmética para que aparezcan los nombres\nrownames(v) <- c('a', 'b', 'c') # de los parámetros (es opcional)\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              a             b             c\na  6.124524e-06 -3.337187e-07  3.910406e-09\nb -3.337187e-07  2.017310e-08 -2.491926e-10\nc  3.910406e-09 -2.491926e-10  3.194776e-12\n```\n\n\n:::\n:::\n\n\nLa diagonal de esta matriz es precisamente la incertidumbre estándar al \ncuadrado de los parámetros (a.k.a sus varianzas). Si queremos, también podemos\nexpresarla como matriz de correlaciones con el comando `cov2cor`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam.cor <- cov2cor(v)\nparam.cor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           a          b          c\na  1.0000000 -0.9494193  0.8840269\nb -0.9494193  1.0000000 -0.9815865\nc  0.8840269 -0.9815865  1.0000000\n```\n\n\n:::\n:::\n\n\nEn la diagonal de esta matriz obviamente esperamos correlación 1. Se observa\nclaramente la alta correlación entre los parámetros, como dijimos anteriormente, \nalgunas de ellas son negativas.\n\nLa parte \"difícil\" es que debemos incorporar la variable señal\ninstrumental de la muestra problema $y_{0}$, la cual obviamente es independiente \nde los parámetros del modelo:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Incorporamos la variable y0 que es independiente de los parámetros\nv <- rbind(v, y0 = rep(0, 3)) \nv <- cbind(v, y0 = rep(0, 4))\nv[4, 4] <- uy0^2 # Asignamos al elemento de la 4a fila y 4a columna  \n                 # la varianza de y0\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               a             b             c           y0\na   6.124524e-06 -3.337187e-07  3.910406e-09 0.000000e+00\nb  -3.337187e-07  2.017310e-08 -2.491926e-10 0.000000e+00\nc   3.910406e-09 -2.491926e-10  3.194776e-12 0.000000e+00\ny0  0.000000e+00  0.000000e+00  0.000000e+00 2.186147e-06\n```\n\n\n:::\n:::\n\n\nAhora, incorporamos las covarianzas en el cálculo por método GUM:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu.GUM.cov <- uncert(expr, x, cov = v, method = \"GUM\")\nu.GUM.cov\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nUncertainty evaluation\n\nCall:\n  uncert.expression(obj = expr, x = x, method = \"GUM\", cov = v)\n\nExpression: (-b + sqrt(b^2 - 4 * (a - y0) * c))/(2 * c)\n\nEvaluation method:  GUM \n\nUncertainty budget:\n   x             u            c           u.c        \na  -5.621212e-03 2.474778e-03   -141.6217 -0.35048212\nb   7.670455e-03 1.420320e-04  -1723.1492 -0.24474238\nc  -2.504209e-05 1.787394e-06 -20966.0252 -0.03747454\ny0  8.400000e-02 1.478563e-03    141.6217  0.20939648\n\n   y:  12.16727\nu(y):  0.2651904 \n```\n\n\n:::\n:::\n\n\n¡Perfecto!, ahora sí, al incluir las covarianzas obtenemos resultados consistentes \ncon el método descrito en la norma ISO 8466-2.\n\n## Estimación con el Método de Monte Carlo\n\nNo detallaremos aquí cómo funciona el método de Monte Carlo, puede consultarlo \nen [este post](https://www.analytical.cl/post/validacion-calculos-incertidumbre-quimica-analitica-metodo-monte-carlo/) y en \n[este otro](https://www.analytical.cl/post/validacion-calculos-incertidumbre-quimica-analitica-metodo-monte-carlo-parte2/).\n\nSería super simple si usamos el package `metRology`, el problema es que el \npackage lanza un error numérico cuando existen covarianzas negativas. Probé \nel ejemplo que incluye el manual de `metRology` y el error se repite. Es un \nproblema al evaluar la suma de las correlaciones. Le \nconsulté al autor Steve Ellison, sin embargo, a la fecha (09 de junio 2020) \naún no tengo respuesta, a pesar de que Steve siempre responde las consultas en\nforma muy expedita. Otros usuarios han tenido un problema similar y se ha \nabierto un hilo en [stackoverflow](https://stackoverflow.com/questions/60971950/error-in-eigensigma-symmetric-true-0-x-0-matrix-in-metrology-uncertmc-wit/62119518#62119518).\n\nPor lo tanto, implementamos el método de Monte Carlo \"a mano\" utilizando el \npackage `MASS` el cual permite generar muestras aleatorias multivariadas \nincluyendo las correlaciones:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# No funciona metRology MC así que lo hicimos a mano\nlibrary(MASS) # cargamos la librería\n\n# Generamos n muestras aleatorias multivariadas, cuyas medias \n# corresponden a los valores de a, b, c e y0\n# La matriz de covarianza Sigma = v la calculamos anteriormente\n\nset.seed(123) # Para que Ud. obtenga los mismos resultados\nmuestra.MC <- mvrnorm(n = 10000, mu = c(a, b, c, y0), Sigma = v, empirical = T)\ncolnames(muestra.MC) <- c('a', 'b', 'c', 'y0') # solo cosmética\nmuestra.MC <- data.frame(muestra.MC) # lo guardamos como data.frame\nhead(muestra.MC) # muestra las primeras n = 6 simulaciones\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             a           b             c         y0\n1 -0.006371785 0.007697494 -2.535336e-05 0.08771566\n2 -0.006657346 0.007727893 -2.572028e-05 0.08385741\n3 -0.005338584 0.007654631 -2.437727e-05 0.08643112\n4 -0.006478276 0.007654191 -2.412670e-05 0.08417975\n5 -0.008126340 0.007832532 -2.697179e-05 0.08478106\n6 -0.005139204 0.007672558 -2.484339e-05 0.08644533\n```\n\n\n:::\n:::\n\n\nCada fila es una simulación. Si, por ejemplo, calculamos el promedio de cada\nvariable simulada, obtenemos un valor similar a los valores empíricos. A mayor \nnúmero de simulaciones, más nos acercamos a valores que asumimos como\nverdaderos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(muestra.MC, 2, mean) # promedio de cada columna\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            a             b             c            y0 \n-5.621212e-03  7.670455e-03 -2.504209e-05  8.400000e-02 \n```\n\n\n:::\n:::\n\n\nBien, lo que tenemos que hacer es que en cada simulación debemos \ncalcular la concentración de la muestra:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# cargaré estas librerías sólo para facilitar la manipulación de los datos\nlibrary(magrittr)\nlibrary(tidyverse)\n\n# Creamos una nueva variable llamada x.hat que corresponde a la concentración de\n# la muestra\nmuestra.MC <- muestra.MC %>% \n  mutate(x.hat = (-b + sqrt(b^2 - 4*(a - y0)*c))/(2*c))\nhead(muestra.MC) # muestra las primeras n = 6 simulaciones\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             a           b             c         y0    x.hat\n1 -0.006371785 0.007697494 -2.535336e-05 0.08771566 12.75935\n2 -0.006657346 0.007727893 -2.572028e-05 0.08385741 12.20883\n3 -0.005338584 0.007654631 -2.437727e-05 0.08643112 12.48521\n4 -0.006478276 0.007654191 -2.412670e-05 0.08417975 12.32289\n5 -0.008126340 0.007832532 -2.697179e-05 0.08478106 12.39039\n6 -0.005139204 0.007672558 -2.484339e-05 0.08644533 12.43752\n```\n\n\n:::\n:::\n\n\nLa última columna corresponde a la concentración calculada para cada \nsimulación. Por lo tanto, si queremos obtener la incertidumbre estándar de \nla concentración, basta calcular la desviación estándar de esa columna:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmu.x.hat.MC <- mean(muestra.MC$x.hat) # valor promedio de concentración\nu.x.hat.MC <- sd(muestra.MC$x.hat) # incertidumbre estándar de la concentración\nu.x.hat.MC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.265344\n```\n\n\n:::\n:::\n\n\nSe obtiene una incertidumbre estándar de calibración de \n0.265 mg/L, la\ncual es consistente con los otros métodos estudiados. La siguiente\nfigura muestra el histograma de las concentraciones simuladas:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(muestra.MC$x.hat, \n     breaks = 20,\n     main = 'Concentraciones simuladas por Monte Carlo',\n     xlab = 'Concentración [mg/L]')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot.u.MC-1.png){width=672}\n:::\n:::\n\n\n\nFinalmente, la siguiente tabla resume los resultados de los tres métodos \nconsiderando la incertidumbre estándar de calibración:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabla <- data.frame(Ix/t, u.GUM$u.y, u.GUM.cov$u.y, u.x.hat.MC)\nknitr::kable(tabla, \n             rownames = NA,\n             col.names = c('ISO', 'GUM', 'GUM/Covarianzas', 'Monte Carlo'),\n             align = 'l')\n```\n\n::: {.cell-output-display}\n\n\n|ISO       |GUM       |GUM/Covarianzas |Monte Carlo |\n|:---------|:---------|:---------------|:-----------|\n|0.2651904 |0.4774807 |0.2651904       |0.265344    |\n\n\n:::\n:::\n\n\nSe aprecia claramente una excelente concordancia entre los tres métodos.\nSin embargo, para que el método GUM entregue resultados correctos, es necesario\nincorporar las covarianzas entre las variables input.\n\nEn un próximo post exploraremos el método _Bootstrap_, un método estadístico \npor excelencia para estimar incertidumbre sin utilizar un modelo de medición...\n\n> ¡Dejad que los datos hablen!\n\n# Bibliografía\n\n1. Norma ISO 8466-2:2001 *Water quality -- Calibration and evaluation of \nanalytical methods and estimation of performance characteristics -- Part 2: \nCalibration strategy for non-linear second-order calibration functions.*\n\n2.  Brandon M. Greenwell and Christine M. Schubert Kabban (2014). investr: An R\nPackage for Inverse Estimation. The R Journal, 6(1), 90-100. URL http://journal.r-project.org/archive/2014-1/greenwell-kabban.pdf.\n\n3. NIST/SEMATECH e-Handbook of Statistical Methods, \n_Uncertainty for quadratic calibration using propagation of error_,\nhttps://www.itl.nist.gov/div898/handbook/mpc/section3/mpc3671.htm, \n09 de junio 2020.\n\n4. Nonlinear multivariate calibration methods in analytical chemistry\nSonja Sekulic, Mary Beth Seasholtz, Ziyi Wang, Bruce R. Kowalski, Samuel E. \nLee, and Bradley R. Holt _Analytical Chemistry 1993 65 (19), 835A-845A_",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}